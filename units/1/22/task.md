# 1.22 задача

## Условие

Большая часть реализаций Лиспа содержат эдементарную процедуру runtime, которая возвращает целое число, показывающее, как долго работала система (например, в милисекундах). Следующая процедура timed-prime-test, будучи вызвана с целым числом n, печатает n и проверяет, простое ли оно. Если n простое, процедура печатает три звездочки и количество времени, затраченное на проверку.

Используя эту процедуру, напишите процедуру search-for-primes, которая проверяет на простоту все нечетные числа в заданном диапозоне. С помощью этой процедуры найдите наименьшие три простых числа после 1000; после 10 000; после 100 000; после 1 000 000. Посмотрите, сколько времени затрачивается на каждое простое число. Поскольку алгоритм проверки имеет порядок роста `О(sqrt(n))`, вам следовало бы ожидать, что проверка на простоту чисел, близких к 10 000, занимает в `sqrt(10)` раз больше времени, чем для чисел, близких к 1000. Подтверждает ли это Ваши замеры времени? Хорошо ли поддерживают предсказание `sqrt(n)` данные для 100 000 и 1 000 000? Совместим ли ваш результат с предположением, что программы на Вашей машине затрачивают на выполнение задач время, пропорциональное числу шагов?

## Решение

После 1000: 1009, 1013, 1019
После 10000: 10007, 10009, 10037
После 100000: 100003, 100019, 100043
После 1000000: 1000003, 1000033, 1000037

# 1.6 task

## Description

Лиза П. Хакер не понимает почему if должна быть особой формой. «Почему нельзя просто определить ее с как обычную процедуру, используя cond?» — спрашивает она. Лизина подруга Ева Лу Атор утверждает, что, разумеется, можно и определяет новую версию if:

```scheme
(define (new-if predicate consequent alternative)
   (cond (predicate consequent)
         (else alternative)))
```

Ева показывает Лизе новую программу:

```scheme
(new-if (= 2 3) 0 5)
; 5
```

```scheme
(new-if (= 1 1) 0 5)
; 0
```

Обрадованная Лиза переписывает через `new-if` программу вычисления квадратного корня:

```scheme
(define (sqrt-iter guess x)
   (new-if (good-enough? guess x)
           guess
           (sqrt-iter (improve guess x)
                      x)))
```

Что получится, когда Лиза использует эту процедуру для вычисления квадратных корней? При нормальном и аппликативном порядке вычислений. Объясните.

## Solution

При нормальном порядке вычислений все будет работать.

При аппликативном порядке процедура `sqrt-iter` будет вычислять себя бесконечно, как альтернативу независимо от предиката, в результате стек переполнится и интерпретатор упадет с ошибкой из-за нехватки памяти.
